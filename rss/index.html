<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[The Unapologetic Blog]]></title><description><![CDATA[Thoughts, stories and ideas.]]></description><link>gfrancoa.github.io/tub-blog//</link><image><url>gfrancoa.github.io/tub-blog//favicon.png</url><title>The Unapologetic Blog</title><link>gfrancoa.github.io/tub-blog//</link></image><generator>Ghost 5.98</generator><lastBuildDate>Thu, 31 Oct 2024 00:52:54 GMT</lastBuildDate><atom:link href="gfrancoa.github.io/tub-blog//rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[OOP 101- Why OOP?]]></title><description><![CDATA[<p>At the beginning, when people started doing code, procedural programming was the way to go: one instruction was written after the other. When applications started gaining complexity, and operations became repetitive, programmers started to implement functions that they could reuse and where they could group a set of instructions to</p>]]></description><link>gfrancoa.github.io/tub-blog//coming-soon/</link><guid isPermaLink="false">672290fa69841c1fb0715a37</guid><category><![CDATA[Technology]]></category><dc:creator><![CDATA[Gabriela F]]></dc:creator><pubDate>Wed, 30 Oct 2024 20:03:06 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1719937050792-a6a15d899281?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wxfDF8YWxsfDF8fHx8fHx8fDE3MzAzMjgwNDJ8&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<img src="https://images.unsplash.com/photo-1719937050792-a6a15d899281?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wxfDF8YWxsfDF8fHx8fHx8fDE3MzAzMjgwNDJ8&amp;ixlib=rb-4.0.3&amp;q=80&amp;w=2000" alt="OOP 101- Why OOP?"><p>At the beginning, when people started doing code, procedural programming was the way to go: one instruction was written after the other. When applications started gaining complexity, and operations became repetitive, programmers started to implement functions that they could reuse and where they could group a set of instructions to be executed that were related to a functionality or a task.</p><p>However, this was not enough. Now the code looked like a never-ending list of random functions. And even though the functionalities could be grouped by files, there was a better way to organize it.</p><blockquote>&#xA0;Remember programming it&apos;s all about modeling the real world and give instructions so detailed that the machine is able to automatize tasks we were doing by ourselves before. Computers, in its original state, are able to compute massive amount of data (faster than a human) but you have to tell them how to do it. They are not able to make decisions or to analyze data by themselves, with the exception of the Artificial Intelligence applications so widely used nowadays, but even those programs had to be taught at the beginning of how to behave and which constraints to include.</blockquote><p>Object Oriented Programming (OOP) was designed as a way to model a system, to make it closer to the real life, grouping both data and behavior in a single entity called class. By data we mean variables and by behavior we mean methods. Just to clarify: The functions inside a class we call them methods and the variables commonly receive the name of members (for the latter exists more names but we will use this one).</p><p><strong>Classes</strong><br>
Think of a class as a template. We can reuse this template as many times as we want. The entities that we create using this template we call them objects, so objects are materializations of a class. In programming we say: an object is an instance of a class.</p>
<p>But take into account that every object can be slightly different (or not) from the other because its members could have different values. For example, I can have the class student, which has as members name, address and date of birth but every object is going to instantiate this class in a different way since the values for the variables can be different.</p>
<p>But what if two objects have the exact same value? Are they the same object? Well, I can print the same book two times but even though they have the same content they are two books, two objects. Every created object normally is located in a different address in memory (take into account this may vary between programming languages and the way they do the memory management).</p>
]]></content:encoded></item></channel></rss>